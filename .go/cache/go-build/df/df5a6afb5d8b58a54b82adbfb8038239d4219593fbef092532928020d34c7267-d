// Code generated by cmd/cgo; DO NOT EDIT.

//line /src/vendor/github.com/mattn/go-sqlite3/backup.go:1:1
// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package sqlite3

/*
#ifndef USE_LIBSQLITE3
#include <sqlite3-binding.h>
#else
#include <sqlite3.h>
#endif
#include <stdlib.h>
*/
import _ "unsafe"
import (
	"runtime"
	"unsafe"
)

// SQLiteBackup implement interface of Backup.
type SQLiteBackup struct {
	b * /*line :24:5*/_Ctype_sqlite3_backup /*line :24:21*/
}

// Backup make backup from src to dest.
func (destConn *SQLiteConn) Backup(dest string, srcConn *SQLiteConn, src string) (*SQLiteBackup, error) {
	destptr := ( /*line :29:13*/_Cfunc_CString /*line :29:21*/)(dest)
	defer func() func() { _cgo0 := /*line :30:15*/unsafe.Pointer(destptr); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	srcptr := ( /*line :31:12*/_Cfunc_CString /*line :31:20*/)(src)
	defer func() func() { _cgo0 := /*line :32:15*/unsafe.Pointer(srcptr); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()

	if b := func() *_Ctype_struct_sqlite3_backup{ _cgo0 := /*line :34:32*/destConn.db; var _cgo1 *_Ctype_char = /*line :34:45*/destptr; _cgo2 := /*line :34:54*/srcConn.db; var _cgo3 *_Ctype_char = /*line :34:66*/srcptr; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_sqlite3_backup_init(_cgo0, _cgo1, _cgo2, _cgo3); }(); b != nil {
		bb := &SQLiteBackup{b: b}
		runtime.SetFinalizer(bb, (*SQLiteBackup).Finish)
		return bb, nil
	}
	return nil, destConn.lastError()
}

// Step to backs up for one step. Calls the underlying `sqlite3_backup_step`
// function.  This function returns a boolean indicating if the backup is done
// and an error signalling any other error. Done is returned if the underlying
// C function returns SQLITE_DONE (Code 101)
func (b *SQLiteBackup) Step(p int) (bool, error) {
	ret := func() _Ctype_int{ _cgo0 := /*line :47:31*/b.b; var _cgo1 _Ctype_int = _Ctype_int(p); _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_backup_step(_cgo0, _cgo1); }()
	if ret == ( /*line :48:12*/_Ciconst_SQLITE_DONE /*line :48:24*/) {
		return true, nil
	} else if ret != 0 && ret != ( /*line :50:31*/_Ciconst_SQLITE_LOCKED /*line :50:45*/) && ret != ( /*line :50:57*/_Ciconst_SQLITE_BUSY /*line :50:69*/) {
		return false, Error{Code: ErrNo(ret)}
	}
	return false, nil
}

// Remaining return whether have the rest for backup.
func (b *SQLiteBackup) Remaining() int {
	return int(func() _Ctype_int{ _cgo0 := /*line :58:40*/b.b; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_backup_remaining(_cgo0); }())
}

// PageCount return count of pages.
func (b *SQLiteBackup) PageCount() int {
	return int(func() _Ctype_int{ _cgo0 := /*line :63:40*/b.b; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_backup_pagecount(_cgo0); }())
}

// Finish close backup.
func (b *SQLiteBackup) Finish() error {
	return b.Close()
}

// Close close backup.
func (b *SQLiteBackup) Close() error {
	ret := func() _Ctype_int{ _cgo0 := /*line :73:33*/b.b; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_backup_finish(_cgo0); }()

	// sqlite3_backup_finish() never fails, it just returns the
	// error code from previous operations, so clean up before
	// checking and returning an error
	b.b = nil
	runtime.SetFinalizer(b, nil)

	if ret != 0 {
		return Error{Code: ErrNo(ret)}
	}
	return nil
}
